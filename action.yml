name: 'Snake Evolution'
description: 'Generate an animated snake eating your GitHub contributions'
author: 'miccy'
branding:
  icon: 'activity'
  color: 'green'

inputs:
  github_user_name:
    description: 'GitHub username to generate snake for'
    required: true

  github_token:
    description: 'GitHub token for API access (optional, uses public scraping if not provided)'
    required: false
    default: ''

  outputs:
    description: 'Output file path(s), comma or newline separated. Append ?palette=<theme>&format=<svg|gif> per output to override.'
    required: false
    default: 'dist/snake.svg'

  theme:
    description: 'Color theme (github-light, github-dark, ocean, sunset, neon-gamer, cypherpunk)'
    required: false
    default: 'github-dark'

  year:
    description: 'Year to generate contributions for'
    required: false
    default: ''  # Current year if empty

outputs:
  svg_path:
    description: 'Path to generated SVG file'
    value: ${{ steps.generate.outputs.svg_path }}

runs:
  using: 'composite'
  steps:
    - name: Setup Bun
      uses: oven-sh/setup-bun@v2
      with:
        bun-version: 1.3.5

    - name: Install dependencies
      shell: bash
      run: |
        cd ${{ github.action_path }}
        bun install --frozen-lockfile

    - name: Generate Snake
      id: generate
      shell: bash
      run: |
        # Parse inputs
        OUTPUTS_RAW="${{ inputs.outputs }}"
        THEME="${{ inputs.theme }}"
        YEAR="${{ inputs.year }}"
        USERNAME="${{ inputs.github_user_name }}"
        TOKEN="${{ inputs.github_token }}"
        ACTION_PATH="${{ github.action_path }}"
        WORKSPACE="${{ github.workspace }}"

        # Split outputs on commas and newlines
        mapfile -t OUTPUTS <<< "$(printf '%s\n' "$OUTPUTS_RAW" | tr ',' '\n')"

        # Base CLI command (run from action path)
        CMD_BASE=(bun run "${ACTION_PATH}/packages/cli/src/index.ts" generate -u "$USERNAME")

        if [ -n "$YEAR" ]; then
          CMD_BASE+=( -y "$YEAR" )
        fi

        if [ -n "$TOKEN" ]; then
          CMD_BASE+=( --token "$TOKEN" )
        fi

        FIRST_OUTPUT=""

        for RAW_OUTPUT in "${OUTPUTS[@]}"; do
          ENTRY="$(echo "$RAW_OUTPUT" | xargs)"

          # Skip empty lines
          if [ -z "$ENTRY" ]; then
            continue
          fi

          # Extract path and query params
          OUTPUT_PATH_REL="${ENTRY%%\?*}"
          OUTPUT_PALETTE="$THEME"
          OUTPUT_FORMAT=""

          if [[ "$ENTRY" == *"?"* ]]; then
            QUERY_STRING="${ENTRY#*\?}"
            IFS='&' read -ra PARAMS <<< "$QUERY_STRING"
            for PARAM in "${PARAMS[@]}"; do
              KEY="${PARAM%%=*}"
              VALUE="${PARAM#*=}"
              case "$KEY" in
                palette)
                  OUTPUT_PALETTE="$VALUE"
                  ;;
                format)
                  OUTPUT_FORMAT="$VALUE"
                  ;;
              esac
            done
          fi

          if [ -z "$FIRST_OUTPUT" ]; then
            FIRST_OUTPUT="$OUTPUT_PATH_REL"
          fi

          OUTPUT_PATH_ABS="${WORKSPACE}/${OUTPUT_PATH_REL}"

          # Validate path is within workspace (resolve symlinks and check prefix)
          RESOLVED_PATH="$(cd "$(dirname "$OUTPUT_PATH_ABS")" 2>/dev/null && pwd -P)/$(basename "$OUTPUT_PATH_ABS")" || {
            echo "Error: Invalid output path: $OUTPUT_PATH_REL"
            continue
          }
          if [[ "$RESOLVED_PATH" != "$WORKSPACE"* ]]; then
            echo "Error: Output path escapes workspace: $OUTPUT_PATH_REL"
            continue
          fi

          CMD=("${CMD_BASE[@]}" -t "$OUTPUT_PALETTE" -o "$OUTPUT_PATH_ABS")
          if [ -n "$OUTPUT_FORMAT" ]; then
            CMD+=( -f "$OUTPUT_FORMAT" )
          fi

          echo "Running: ${CMD[*]}"
          "${CMD[@]}"
        done

        # Set output (relative path for user convenience)
        if [ -n "$FIRST_OUTPUT" ]; then
          echo "svg_path=$FIRST_OUTPUT" >> $GITHUB_OUTPUT
        fi
